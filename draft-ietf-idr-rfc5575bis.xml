<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC0768 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0768.xml">
<!ENTITY RFC0791 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0791.xml">
<!ENTITY RFC0792 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0792.xml">
<!ENTITY RFC0793 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0793.xml">
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2474 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2474.xml">
<!ENTITY RFC3882 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3882.xml">
<!ENTITY RFC4271 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4271.xml">
<!ENTITY RFC4303 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4303.xml">
<!ENTITY RFC4360 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4360.xml">
<!ENTITY RFC4364 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4364.xml">
<!ENTITY RFC4456 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4456.xml">
<!ENTITY RFC4760 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4760.xml">
<!ENTITY RFC5635 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5635.xml">
<!ENTITY RFC5575 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5575.xml">
<!ENTITY RFC7153 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7153.xml">
<!ENTITY RFC7223 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7223.xml">
<!ENTITY RFC7606 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7606.xml">
<!ENTITY RFC7674 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7674.xml">
<!ENTITY RFC7999 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7999.xml">
<!ENTITY RFC8126 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8126.xml">
<!ENTITY RFC8174 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8174.xml">
<!ENTITY RFC6811 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6811.xml">
<!ENTITY RFC8205 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8205.xml">
<!ENTITY I-D.ietf-idr-flow-spec-v6 SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-idr-flow-spec-v6.xml">
<!ENTITY I-D.vandevelde-idr-flowspec-path-redirect SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.vandevelde-idr-flowspec-path-redirect.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<?rfc iprnotified="no" ?>
<?rfc strict="no" ?>
<rfc category="std" docName="draft-ietf-idr-rfc5575bis-18" ipr="trust200902" obsoletes="5575,7674">
  <front>
   <title abbrev="Flow Specification">Dissemination of Flow Specification Rules</title>
   <author fullname="Christoph Loibl" initials="C.L."
           surname="Loibl">
     <organization>Next Layer Communications</organization>
     <address>
       <postal>
         <street>Mariahilfer Guertel 37/7</street>
         <city>Vienna</city>
         <region></region>
         <code>1150</code>
         <country>AT</country>
       </postal>
       <phone>+43 664 1176414</phone>
       <email>cl@tix.at</email>
     </address>
   </author>
    <author fullname="Susan Hares" initials="S" surname="Hares">
      <organization>Huawei</organization>
      <address>
        <postal>
          <street>7453 Hickory Hill</street>
          <city>Saline</city>
          <region>MI</region>
          <code>48176</code>
          <country>USA</country>
        </postal>
        <email>shares@ndzh.com</email>
      </address>
	</author>
    <author fullname="Robert Raszuk" initials="R" surname="Raszuk">
      <organization>Bloomberg LP</organization>
	  <address>
        <postal>
         <street>731 Lexington Ave</street>
          <city>New York City</city>
          <region>NY</region>
          <code>10022</code>
		   <country>USA</country>
		</postal>
        <email>robert@raszuk.net </email>
      </address>
    </author>

	     <author fullname="Danny McPherson" initials="D" surname="McPherson">
      <organization>Verisign</organization>
      <address>
        <postal>
          <street></street>
          <city></city>
          <code></code>
          <country>USA</country>
        </postal>
        <email>dmcpherson@verisign.com</email>
      </address>
    </author>

<author fullname="Martin Bacher" initials="M.B."
    surname="Bacher">
    <organization>T-Mobile Austria</organization>
    <address>
        <postal>
            <street>Rennweg 97-99</street>
            <city>Vienna</city>
            <region></region>
            <code>1030</code>
            <country>AT</country>
        </postal>
        <email>mb.ietf@gmail.com</email>
    </address>
</author>
    <date year="2019" />
    <area>Routing Area</area>
    <workgroup>IDR Working Group</workgroup>
    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>Dissemination of Flow Specification Rules</keyword>
	<abstract>
   <t>
   This document obsoletes both <xref target="RFC5575" /> and <xref target="RFC7674" />.
   </t>
	<t>
   This document defines a Border Gateway Protocol Network Layer
   Reachability Information (BGP NLRI) encoding format, that can be used
   to distribute traffic Flow Specifications. This allows the routing
   system to propagate information regarding more specific components of
   the traffic aggregate defined by an IP destination prefix.
   </t>
   <t>
   It also specifies BGP Extended Community encoding formats, that can be
   used to propagate Traffic Filtering Actions along with the Flow
   Specification NLRI. Those Traffic Filtering Actions encode actions a
   routing system can take if the packet matches the Flow Specification.
   </t>
   <t>
   Additionally, it defines two applications of that encoding format:
   one that can be used to automate inter-domain coordination of traffic
   filtering, such as what is required in order to mitigate
   (distributed) denial-of-service attacks, and a second application to
   provide traffic filtering in the context of a BGP/MPLS VPN service.
   Other applications (ie. centralized control of traffic
   in a SDN or NFV context) are also possible. Other drafts specify IPv6,
   MPLS addresses, L2VPN addresses, and NV03 encapsulation of IP addresses
   as Flow Specification extensions.
   </t>
   <t>
   The information is carried via the BGP, thereby reusing protocol
   algorithms, operational experience, and administrative processes such
   as inter-provider peering agreements.
   </t>
    </abstract>
  </front>
  <middle>
    <section anchor="intro" title="Introduction">
   <t>
   This document obsoletes both "<xref target="RFC5575" format="title" />" <xref target="RFC5575" />
       and "<xref target="RFC7674" format="title" />"<xref target="RFC7674" />.
   </t>
   <t>
	Modern IP routers contain both the capability to forward traffic
    according to IP prefixes as well as to classify, shape, rate limit,
    filter, or redirect packets based on administratively defined
    policies.
	  </t>
	  <t>
    These traffic policy mechanisms allow the operator to define match
    rules that operate on multiple fields of the packet header.  Actions
    such as the ones described above can be associated with each rule.
	</t>
	<t>
    The n-tuple consisting of the matching criteria defines an aggregate
    traffic Flow Specification. The matching criteria can include
    elements such as source and destination address prefixes, IP
    protocol, and transport protocol port numbers.
	</t>
	<t>
   <xref target="dissemination_ipv4_flowspec" /> of this document defines a general procedure to encode Flow
   Specification for aggregated traffic flows so that they can be
   distributed as a BGP <xref target="RFC4271" /> NLRI.
   Additionally, <xref target="traffic_filtering_actions" /> of this document defines the
   required Traffic Filtering Actions BGP Extended Communities
   and mechanisms to use BGP for intra- and inter-provider
   distribution of traffic filtering rules to filter (distributed)
   denial-of-service (DoS) attacks.
	</t>
	<t>
	By expanding routing information with Flow Specifications, the
	routing system can take advantage of the ACL (Access Control List) or
	firewall capabilities in the router's forwarding path.  Flow
	Specifications can be seen as more specific routing entries to a
	unicast prefix and are expected to depend upon the existing unicast
	data information.
	</t>
	<t>
	A Flow Specification received from a different administrative domain will
	need to be validated against unicast routing before being accepted
    (<xref target="validation_procedure" />).
	If the aggregate traffic flow defined by the unicast destination
    prefix is forwarded to a given BGP peer, then the local system can
    install more specific Flow Specifications that may result in different
    forwarding behavior, as requested by this system.
	</t>
   <t>
   From an operational perspective, the utilization of BGP as the
   carrier for this information allows a network service provider to
   reuse both internal route distribution infrastructure (e.g., route
   reflector or confederation design) and existing external
   relationships (e.g., inter-domain BGP sessions to a customer
   network).
   </t>
   <t>
   While it is certainly possible to address this problem using other
   mechanisms, this solution has been utilized in deployments because of the
   substantial advantage of being an incremental addition to already
   deployed mechanisms.
   </t>
   <t>In current deployments, the information distributed by this
   extension is originated both manually as well as automatically. The
   latter by systems that are able to detect malicious traffic flows.  When
   automated systems are used, care should be taken to ensure their
   correctness as well as the limitations of the systems that receive and
   process the advertised Flow Specifications
   (see also <xref target="security_considerations" />).
   </t>
   <t>
   This specification defines required protocol extensions to address
   most common applications of IPv4 unicast and VPNv4 unicast filtering.
   The same mechanism can be reused and new match criteria added to
   address similar filtering needs for other BGP address families such as
   IPv6 families <xref target="I-D.ietf-idr-flow-spec-v6"></xref>.
   </t>
   <t>
       This specification addresses limitations in previous
       traffic filtering efforts for DDoS traffic filtering and traffic filtering
       in provider-based Layer-3 VPN networks as discussed below:
   </t>
   <section anchor="limitations_previous_ddos" title="Limitations in Previous DDoS Traffic Filtering Efforts">
<t>The popularity of traffic-based, denial-of-service (DoS) attacks,
   which often requires the network operator to be able to use traffic
   filters for detection and mitigation, brings with it requirements
   that are not fully satisfied by existing tools.
</t>
       <t>
     Increasingly, DoS mitigation requires coordination among several
   service providers in order to be able to identify traffic source(s)
   and because the volumes of traffic may be such that they will
   otherwise significantly affect the performance of the network.
</t>
<t>
   Several techniques are currently used to control traffic filtering of
   DoS attacks (<xref target="RFC3882" />, <xref target="RFC5635" />,
    <xref target="RFC7999" />, ...).
   Among those, one of the most common is to inject
   unicast route advertisements corresponding to a destination prefix
   being attacked (commonly known as remote triggered blackhole RTBH).
   One variant of this technique marks such route
   advertisements with a community that gets translated into a discard
   Next Hop by the receiving router. Other variants attract traffic
   to a particular node that serves as a deterministic drop point.
</t>
<t>
   Using unicast routing advertisements to distribute traffic filtering
   information has the advantage of using the existing infrastructure
   and inter-AS communication channels.  This can allow, for instance, a
   service provider to accept filtering requests from customers for
   address space they own.
</t>
<t>
   There are several drawbacks, however.  An issue that is immediately
   apparent is the granularity of filtering control: only destination
   prefixes may be specified.  Another area of concern is the fact that
   filtering information is intermingled with routing information.
</t>
<t>
   The mechanism defined in this document is designed to address these
   limitations. I makes use the Flow Specification NLRI defined in <xref target="dissemination_ipv4_flowspec" /> to
   convey information about traffic filtering rules for traffic that
   is subject to modified forwarding behavior (Traffic Filtering Actions). The actions
   are defined as extended communities and include (but are not limited
   to) rate-limiting (including discard), traffic redirection, packet
   rewriting.
</t>
</section>
    <section anchor="limitations_previous_mpls_ddos" title="Limitations in Previous BGP/MPLS Traffic Filtering Efforts">
    <t>
       Provider-based Layer 3 VPN networks, such as the ones using a BGP/
       MPLS IP VPN <xref target="RFC4364"></xref> control plane, may have different traffic filtering
       requirements than Internet service providers.
    </t>
    <t>
       In these environments, the VPN customer network often has traffic
       filtering capabilities towards their external network connections
       (e.g., firewall facing public network connection).  Less common is
       the presence of traffic filtering capabilities between different VPN
       attachment sites.  In an any-to-any connectivity model, which is the
       default, this means that site-to-site traffic is unfiltered.
    </t>
    <t>
       In circumstances where a security threat does get propagated inside
       the VPN customer network, there may not be readily available
       mechanisms to provide mitigation via traffic filter.
    </t>
    <t>
    But also Internet service providers may use those VPNs for scenarios like
    having the Internet routing table in a VRF. Therefore, limitations described
    in <xref target="limitations_previous_ddos"></xref> also apply to this section.
    </t>
    <t>This BGP extension addresses these limitations.
    </t>
    </section>
    </section>
	<section title="Definitions of Terms Used in This Memo">
	<t>
	<list style="hanging">
	<t hangText="NLRI - ">Network Layer Reachability Information.
	</t>
	<t hangText="RIB - ">Routing Information Base.
	</t>
	<t hangText="Loc-RIB - ">
        The Loc-RIB contains the routes that have been selected by the
        local BGP speaker's Decision Process.
	</t>
	<t hangText="AS - ">Autonomous System.
	</t>
	<t hangText="VRF - ">Virtual Routing and Forwarding instance.
	</t>
    <t hangText="PE - ">Provider Edge router
	</t>
	</list>
	</t>
	<t>
    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
    NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
    "MAY", and "OPTIONAL" in this document are to be interpreted as
    described in BCP 14 <xref target="RFC2119"></xref> <xref target="RFC8174"></xref>
    when, and only when, they appear in all capitals, as shown here.
	</t>
	</section>
	<section title="Flow Specifications">
	<t>
	 A Flow Specification is an n-tuple consisting of several matching
	criteria that can be applied to IP traffic.  A given IP packet is
	said to match the defined Flow Specification if it matches all the specified
	criteria. This n-tuple is encoded into a BGP NLRI defined below.
	</t>
  <t>

  </t>
	<t>A given Flow Specification may be associated with a set of attributes, depending on
   the particular application; such attributes may or may not include
   reachability information (i.e., NEXT_HOP).  Well-known or AS-specific
   community attributes can be used to encode a set of predetermined
   actions.
   </t>
   <t>
     A particular application is identified by a specific (Address Family
     Identifier, Subsequent Address Family Identifier (AFI, SAFI)) pair <xref
     target="RFC4760"></xref> and corresponds to a distinct set of RIBs.  Those
     RIBs should be treated independently from each other in order to assure
     non-interference between distinct applications.
   </t>
   <t>
     BGP itself treats the NLRI as a key to an entry in its
     databases.  Entries that are placed in the Loc-RIB are then
     associated with a given set of semantics, which is application
     dependent.  This is consistent with existing BGP applications.  For
     instance, IP unicast routing (AFI=1, SAFI=1) and IP multicast
     reverse-path information (AFI=1, SAFI=2) are handled by BGP without
     any particular semantics being associated with them until installed
     in the Loc-RIB.
	</t>
	<t>
   Standard BGP policy mechanisms, such as UPDATE filtering by NLRI
   prefix as well as community matching and manipulation, must apply to the Flow Specification
   defined NLRI-type, especially in an inter-domain environment.
   Network operators can also control propagation of such
   routing updates by enabling or disabling the exchange of a particular
   (AFI, SAFI) pair on a given BGP peering session.
	</t>
	</section>
	<section title="Dissemination of IPv4 FLow Specification Information" anchor="dissemination_ipv4_flowspec">
	<t>
	This document defines a Flow Specification NLRI type (<xref target="fs_nlri" />)
  that may include several components such as destination prefix,
  source prefix, protocol, ports, and others (see
  <xref target="nlri_value_encoding" /> below).
 	</t>
	<t>
	 This NLRI information is encoded using MP_REACH_NLRI and
	MP_UNREACH_NLRI attributes as defined in  <xref target="RFC4760"></xref>.
	Whenever the corresponding application does not require Next Hop
	information, this shall be encoded as a 0-octet length Next Hop in
	the MP_REACH_NLRI attribute (if a non 0-octet Next Hop is present
    it should be ignored on receipt).
	</t>
	<t>
	 The NLRI field of the MP_REACH_NLRI and MP_UNREACH_NLRI is encoded as
	a 1- or 2-octet NLRI length field followed by a variable-length NLRI
	value.  The NLRI length is expressed in octets.
	</t>
	<t>
	<figure title="Flow Specification NLRI for IPv4" anchor="fs_nlri">
	<artwork>
                  +-------------------------------+
                  |    length (0xnn or 0xfnnn)    |
                  +-------------------------------+
                  |    NLRI value   (variable)    |
                  +-------------------------------+
	</artwork>
	</figure>
	</t>
   <t>
   Implementations wishing to exchange Flow Specification MUST use
   BGP's Capability Advertisement facility to exchange the Multiprotocol
   Extension Capability Code (Code 1) as defined in <xref target="RFC4760"></xref>.
   The (AFI, SAFI) pair carried in the Multiprotocol Extension
   Capability MUST be (AFI=1, SAFI=133) for IPv4 Flow Specification, and
   (AFI=1, SAFI=134) for VPNv4 Flow Specification.
   </t>
	<section title="Length Encoding">
    <t>
	<list style="symbols">
	<t>If the NLRI length is smaller than 240 (0xf0 hex) octets, the length
   field can be encoded as a single octet.  </t>
    <t>Otherwise, it is encoded as
    an extended-length 2-octet value in which the most significant nibble
    of the first byte is all ones.</t>
	</list>
	</t>
	<t>
	 In <xref target="fs_nlri" /> above, values less-than 240 are encoded using two hex
	digits (0xnn).  Values above 239 are encoded using 3 hex digits
	(0xfnnn).  The highest value that can be represented with this
	encoding is 4095. For example the length value of 239 is encoded as 0xef (single octet)
    while 240 is encoded as 0xf0f0 (2-octet).
	</t>
	</section>
	<section anchor="nlri_value_encoding" title="NLRI Value Encoding">
	<t>
    The Flow Specification NLRI value consists of a list of optional
   components and is encoded as follows:
   </t>
   <t>Encoding: &lt;[component]+&gt;</t>
   <t>
   A specific packet is considered to match the Flow
   Specification when it matches the intersection (AND) of all the
   components present in the Flow Specification.
  </t>
   <t>
   Components must follow strict type ordering by increasing
   numerical order. A given component type may (exactly once) or may not be
   present in the Flow Specification. If present, it MUST precede any component of
   higher numeric type value.
   </t>
   <t>
       All combinations of components within a single Flow Specification are allowed. However,
       some combinations cannot match any packets (ie. "ICMP Type AND Port" will never
       match any packets), and thus SHOULD not be propagated by BGP.
   </t>
   <section anchor="operators" title="Operators">
       <t>
       Most of the components described below make use of
       comparison operators. Which of the two operators is used is defined
       by the components in <xref target="flowspec_components" />. The operators are
       encoded as a single octet.
       </t>
       <section anchor="numeric_operator" title="Numeric Operator (numeric_op)">
<t>This operator is encoded as shown in <xref target="figure_numeric_operator" />.
<figure title="Numeric Operator (numeric_op)" anchor="figure_numeric_operator">
<artwork>
                    0   1   2   3   4   5   6   7
                  +---+---+---+---+---+---+---+---+
                  | e | a |  len  | 0 |lt |gt |eq |
                  +---+---+---+---+---+---+---+---+
</artwork>
</figure>
<list style="hanging">
<t hangText="e -">end-of-list bit: Set in the last {op, value} pair in the list.
</t>
<t hangText="a -">AND bit:  If unset, the previous term is logically ORed with the current
one.  If set, the operation is a logical AND. In the first operator byte of a sequence
it SHOULD be encoded as unset and and MUST be treated as always unset on decoding.
The AND operator has higher priority than OR for
the purposes of evaluating logical expressions.
</t>
<t hangText="len -">length: The length of the value field for this operator given as (1 &lt;&lt; len). This
  encodes 1 (len=00), 2 (len=01), 4 (len=10), 8 (len=11) bytes.
</t>
<t hangText="0 -">SHOULD be set to 0 on NLRI encoding, and MUST be ignored during decoding
</t>
<t hangText="lt -">less than comparison between data and value.
</t>
<t hangText="gt -">greater than comparison between data and value.
</t>
<t hangText="eq -">equality between data and value.
</t>
</list>
</t>
<t>
  The bits lt, gt, and eq can be combined to produce common
       relational operators such as "less or equal", "greater or equal",
       and "not equal to" as shown in <xref target="table_comparison_operator" />.
</t>
    <texttable anchor="table_comparison_operator" title="Comparison operation combinations">
        <ttcol align="center">lt</ttcol>
        <ttcol align="center">gt</ttcol>
        <ttcol align="center">eq</ttcol>
        <ttcol align="left">Resulting operation</ttcol>
        <c>0</c><c>0</c><c>0</c><c> false (independent of the value)</c>
        <c>0</c><c>0</c><c>1</c><c> == (equal) </c>
        <c>0</c><c>1</c><c>0</c><c> &gt; (greater than) </c>
        <c>0</c><c>1</c><c>1</c><c> &gt;= (greater than or equal)</c>
        <c>1</c><c>0</c><c>0</c><c> &lt; (less than)</c>
        <c>1</c><c>0</c><c>1</c><c> &lt;= (less than or equal)</c>
        <c>1</c><c>1</c><c>0</c><c> != (not equal value)</c>
        <c>1</c><c>1</c><c>1</c><c> true (independent of the value)</c>
    </texttable>

       </section>
       <section anchor="bitmask_operator" title="Bitmask Operator (bitmask_op)">
<t>This operator is encoded as shown in <xref target="figure_bitmask_operator" />.
<figure title="Bitmask Operator (bitmask_op)" anchor="figure_bitmask_operator">
<artwork>
                    0   1   2   3   4   5   6   7
                  +---+---+---+---+---+---+---+---+
                  | e | a |  len  | 0 | 0 |not| m |
                  +---+---+---+---+---+---+---+---+
</artwork>
</figure>
</t>
<t>
<list style="hanging">
<t hangText="e, a, len - Most significant nibble:">(end-of-list bit, AND
 bit, and length field), as defined in the Numeric Operator format in <xref target="numeric_operator" />.
</t>
<t hangText="not - NOT bit:"> If set, logical negation of operation.
</t>
<t hangText="m - Match bit:"> If set, this is a bitwise match operation
defined as "(data AND value) == value"; if unset, (data AND value) evaluates
to TRUE if any of the bits in the value mask are set in the data
</t>
<t hangText="0 - all 0 bits:"> SHOULD be set to 0 on NLRI encoding, and MUST be ignored during decoding
</t>
</list>
</t>


       </section>

   </section>
<section anchor="flowspec_components" title="Components">
   <t>
     The encoding of each of the components begins with a type field
     (1 octet) followed by a variable length parameter. The following sections
     define component types and parameter encodings for the IPv4 IP layer and
     transport layer headers. IPv6 NLRI component types are described
     in <xref target="I-D.ietf-idr-flow-spec-v6"></xref>.
   </t>
<section anchor="type_1" title="Type 1 - Destination Prefix" toc="include">
<t>Encoding: &lt;type (1 octet), length (1 octet), prefix (variable)>
</t>
<t>Defines the destination prefix to match. The length and prefix fields are
encoded as in BGP UPDATE messages <xref target="RFC4271" />
</t>
</section>
<section anchor="type_2" title="Type 2 - Source Prefix" toc="include">
<t>Encoding: &lt;type (1 octet), length (1 octet), prefix (variable)&gt;
</t>
<t>Defines the source prefix to match. The length and prefix fields are
encoded as in BGP UPDATE messages <xref target="RFC4271" />
</t>
</section>
<section anchor="type_3" title="Type 3 - IP Protocol" toc="include">
<t>Encoding: &lt;type (1 octet), [numeric_op, value]+&gt;
</t>
<t>Contains a list of {numeric_op, value} pairs that are used to
match the IP protocol value byte in IP packets.
</t>
<t>
    This component uses the
    Numeric Operator (numeric_op) described in <xref target="numeric_operator" />.
    Type 3 component values SHOULD be encoded as single byte (numeric_op len=00).
</t>
</section>
<section anchor="type_4" title="Type 4 - Port" toc="include">
<t>Encoding: &lt;type (1 octet), [numeric_op, value]+&gt;
</t>
<t>Defines a list of {numeric_op, value} pairs that matches source
   OR destination TCP/UDP ports (see <xref target="RFC0793" /> Section 3.1 and
    <xref target="RFC0768" /> Section "Format").
   This component matches if either the destination port OR the source port
   of a IP packet matches the value.
</t>
<t>
    This component uses the
    Numeric Operator (numeric_op) described in <xref target="numeric_operator" />.
    Type 4 component values SHOULD be encoded as 1- or 2-byte quantities (numeric_op len=00 or len=01).
</t>
<t>
    In case of the presence of the port (destination-port, source-port)
    component only TCP or UDP packets can match the entire Flow Specification.
    The port component, if present, never matches when the packet's IP
    protocol value is not 6 (TCP) or 17 (UDP), if the packet is fragmented
    and this is not the first fragment, or if the system is unable to
    locate the transport header. Different implementations may or may not be
    able to decode the transport header in the presence of IP
    options or Encapsulating Security Payload (ESP) NULL
    <xref target="RFC4303"></xref> encryption.
</t>
</section>
<section anchor="type_5" title="Type 5 - Destination Port" toc="include">
<t>Encoding: &lt;type (1 octet), [numeric_op, value]+&gt;
</t>
<t> Defines a list of {numeric_op, value} pairs used to match the
    destination port of a TCP or UDP packet (see also <xref target="RFC0793" /> Section 3.1 and
    <xref target="RFC0768" /> Section "Format").
</t>
<t>
    This component uses the Numeric Operator (numeric_op) described in <xref target="numeric_operator" />.
    Type 5 component values SHOULD be encoded as 1- or 2-byte quantities (numeric_op len=00 or len=01).
</t>
<t>The last paragraph of <xref target="type_4" /> also applies to this component.</t>
</section>
<section anchor="type_6" title="Type 6 - Source Port" toc="include">
<t>Encoding: &lt;type (1 octet), [numeric_op, value]+&gt;
</t>
<t>  Defines a list of {numeric_op, value} pairs used to match the
    source port of a TCP or UDP packet (see also <xref target="RFC0793" /> Section 3.1 and
    <xref target="RFC0768" /> Section "Format").
</t>
<t>
    This component uses the Numeric Operator (numeric_op) described in <xref target="numeric_operator" />.
    Type 6 component values SHOULD be encoded as 1- or 2-byte quantities (numeric_op len=00 or len=01).
</t>
<t>The last paragraph of <xref target="type_4" /> also applies to this component.</t>
</section>
<section anchor="type_7" title="Type 7 - ICMP type" toc="include">
<t>Encoding: &lt;type (1 octet), [numeric_op, value]+&gt;
</t>
<t>Defines a list of {numeric_op, value} pairs used to match the
type field of an ICMP packet (see also <xref target="RFC0792" /> Section "Message Formats").
</t>
<t>
    This component uses the
    Numeric Operator (numeric_op) described in <xref target="numeric_operator" />.
    Type 7 component values SHOULD be encoded as single byte (numeric_op len=00).
</t>
<t>
    In case of the presence of the ICMP type (code)
    component only ICMP packets can match the entire Flow Specification.
    The ICMP type (code) component, if present, never matches when the packet's IP
    protocol value is not 1 (ICMP), if the packet is fragmented
    and this is not the first fragment, or if the system is unable to
    locate the transport header. Different implementations may or may not be
    able to decode the transport header in the presence of IP
    options or Encapsulating Security Payload (ESP) NULL
    <xref target="RFC4303"></xref> encryption.
</t>
</section>
<section anchor="type_8" title="Type 8 - ICMP code" toc="include">
<t>Encoding: &lt;type (1 octet), [numeric_op, value]+&gt;
</t>
<t>
Defines a list of {numeric_op, value} pairs used to match the
code field of an ICMP packet (see also <xref target="RFC0792" /> Section "Message Formats").
</t>
<t>
    This component uses the
    Numeric Operator (numeric_op) described in <xref target="numeric_operator" />.
    Type 8 component values SHOULD be encoded as single byte (numeric_op len=00).
</t>
<t>The last paragraph of <xref target="type_7" /> also applies to this component.</t>
</section>
<section anchor="type_9" title="Type 9 - TCP flags" toc="include">
<t>Encoding: &lt;type (1 octet), [bitmask_op, bitmask]+&gt;
</t>
<t>
Defines a list of {bitmask_op, bitmask} pairs used to match TCP Control Bits
(see also <xref target="RFC0793"></xref> Section 3.1).
</t>
    <t>
    This component uses the
    Bitmask Operator (bitmask_op) described in <xref target="bitmask_operator" />.
    Type 9 component bitmasks MUST be encoded as 1- or 2-byte bitmask (bitmask_op len=00 or len=01).
    </t>
    <t>When a single byte (bitmask_op len=00) is specified, it matches byte 14 of the TCP
header (see also <xref target="RFC0793"></xref> Section 3.1), which contains
the TCP Control Bits. When a 2-byte (bitmask_op len=01) encoding is used, it matches bytes
13 and 14 of the TCP header with the data offset (leftmost 4 bits) always
    treated as 0.
</t>
<t>
    In case of the presence of the TCP flags
    component only TCP packets can match the entire Flow Specification.
    The TCP flags component, if present, never matches when the packet's IP
    protocol value is not 6 (TCP), if the packet is fragmented
    and this is not the first fragment, or if the system is unable to
    locate the transport header. Different implementations may or may not be
    able to decode the transport header in the presence of IP
    options or Encapsulating Security Payload (ESP) NULL
    <xref target="RFC4303"></xref> encryption.
</t>
</section>
<section anchor="type_10" title="Type 10 - Packet length" toc="include">
<t>Encoding: &lt;type (1 octet), [numeric_op, value]+&gt;
</t>
<t>
  Defines a list of {numeric_op, value} pairs used to match on the total
  IP packet length (excluding Layer 2 but including IP header).
</t>
<t>
    This component uses the Numeric Operator (numeric_op) described in <xref target="numeric_operator" />.
    Type 10 component values SHOULD be encoded as 1- or 2-byte quantities (numeric_op len=00 or len=01).
</t>
</section>
<section anchor="type_11" title="Type 11 - DSCP (Diffserv Code Point)" toc="include">
<t>Encoding: &lt;type (1 octet), [numeric_op, value]+&gt;
</t>
<t> Defines a list of {numeric_op, value} pairs used to match the
6-bit DSCP field (see also <xref target="RFC2474"></xref>).
</t>
<t>
    This component uses the
    Numeric Operator (numeric_op) described in <xref target="numeric_operator" />.
    Type 11 component values MUST be encoded as single byte (numeric_op len=00).
</t>
<t>
    The six least significant bits contain the DSCP value. All other bits SHOULD be
    treated as 0.
</t>
</section>
<section anchor="type_12" title="Type 12 - Fragment" toc="include">
<t>Encoding: &lt;type (1 octet), [bitmask_op, bitmask]+&gt;
</t>
<t> Defines a list of {bitmask_op, bitmask} pairs used to match specific IP fragments.
</t>
    <t>
    This component uses the
    Bitmask Operator (bitmask_op) described in <xref target="bitmask_operator" />.
    The Type 12 component bitmask MUST be encoded as single byte bitmask (bitmask_op len=00).
    </t>
<t>
<figure title="Fragment Bitmask Operand" anchor="figure_fragment_bitmask_operand">
<artwork>
                   0   1   2   3   4   5   6   7
                 +---+---+---+---+---+---+---+---+
                 | 0 | 0 | 0 | 0 |LF |FF |IsF|DF |
                 +---+---+---+---+---+---+---+---+
</artwork>
</figure>
</t>
<t>Bitmask values:
<list style="hanging">
<t hangText="DF -">Don't fragment - match if <xref target="RFC0791" /> IP Header Flags Bit-1 (DF) is 1
</t>
<t hangText="IsF -">Is a fragment - match if <xref target="RFC0791" /> IP Header Fragment Offset is not 0
</t>
<t hangText="FF -">First fragment - match if <xref target="RFC0791" /> IP Header Fragment Offset is 0 AND Flags Bit-2 (MF) is 1
</t>
<t hangText="LF -">Last fragment - match if <xref target="RFC0791" /> IP Header Fragment Offset is not 0 AND Flags Bit-2 (MF) is 0
</t>
<t hangText="0 -">SHOULD be set to 0 on NLRI encoding, and MUST be ignored during decoding
</t>
</list>
</t>
</section>
</section>
</section>
<section title="Examples of Encodings">
 <section title="Example 1" toc="exclude">
<t>
 An example of a Flow Specification NLRI encoding for: "all packets to
    192.0.2.0/24 and TCP port 25".
</t>
 <t>
 <figure>
 <artwork>
       +--------+----------------+----------+----------+
       | length | destination    | protocol | port     |
       +--------+----------------+----------+----------+
       | 0x0b   | 01 18 c0 00 02 | 03 81 06 | 04 81 19 |
       +--------+----------------+----------+----------+
 </artwork>
 </figure>
 </t>
<t>
   Decoded:
<figure>
<artwork>
       +-------+------------+------------------------------+
       | Value |            |                              |
       +-------+------------+------------------------------+
       |  0x0b | length     | 11 octets (len&lt;240 1-octet)  |
       |  0x01 | type       | Type 1 - Destination Prefix  |
       |  0x18 | length     | 24 bit                       |
       |  0xc0 | prefix     | 192                          |
       |  0x00 | prefix     | 0                            |
       |  0x02 | prefix     | 2                            |
       |  0x03 | type       | Type 3 - IP Protocol         |
       |  0x81 | numeric_op | end-of-list, value size=1, = |
       |  0x06 | value      | IP Protocol 6 = TCP          |
       |  0x04 | type       | Type 4 - Port                |
       |  0x81 | numeric_op | end-of-list, value size=1, = |
       |  0x19 | value      | 25                           |
       +-------+------------+------------------------------+
</artwork>
</figure>
    This constitutes an NLRI with an NLRI length of 11 octets.
</t>
</section>
 <section title="Example 2" toc="exclude">
     <t>
   An example of a Flow Specification NLRI encoding for: "all packets to
   192.0.2.0/24 from 203.0.113.0/24 and port {range [137, 139] or 8080}".
<figure>
<artwork>
 +--------+----------------+----------------+-------------------------+
 | length | destination    | source         | port                    |
 +--------+----------------+----------------+-------------------------+
 |  0x12  | 01 18 c0 00 02 | 02 18 cb 00 71 | 04 03 89 45 8b 91 1f 90 |
 +--------+----------------+----------------+-------------------------+
</artwork>
</figure>
</t>
<t>
   Decoded:
<figure>
<artwork>
       +--------+------------+------------------------------+
       | Value  |            |                              |
       +--------+------------+------------------------------+
       |   0x12 | length     | 18 octets (len&lt;240 1-octet)  |
       |   0x01 | type       | Type 1 - Destination Prefix  |
       |   0x18 | length     | 24 bit                       |
       |   0xc0 | prefix     | 192                          |
       |   0x00 | prefix     | 0                            |
       |   0x02 | prefix     | 2                            |
       |   0x02 | type       | Type 2 - Source Prefix       |
       |   0x18 | length     | 24 bit                       |
       |   0xcb | prefix     | 203                          |
       |   0x00 | prefix     | 0                            |
       |   0x71 | prefix     | 113                          |
       |   0x04 | type       | Type 4 - Port                |
       |   0x03 | numeric_op | value size=1, &gt;=             |
       |   0x89 | value      | 137                          |
       |   0x45 | numeric_op | "AND", value size=1, &lt;=      |
       |   0x8b | value      | 139                          |
       |   0x91 | numeric_op | end-of-list, value size=2, = |
       | 0x1f90 | value      | 8080                         |
       +--------+------------+------------------------------+
</artwork>
</figure>
This constitutes an NLRI with an NLRI length of 18 octets.
</t>
</section>
 <section title="Example 3" toc="exclude">
     <t>
   An example of a Flow Specification NLRI encoding for: "all packets to
   192.0.2.1/32 and fragment { DF or FF } (matching packet with DF bit set or First Fragments)
<figure>
<artwork>
       +--------+-------------------+----------+
       | length | destination       | fragment |
       +--------+-------------------+----------+
       |  0x09  | 01 20 c0 00 02 01 | 0c 80 05 |
       +--------+-------------------+----------+
</artwork>
</figure>
</t>
<t>
       Decoded:
<figure>
<artwork>
       +-------+------------+------------------------------+
       | Value |            |                              |
       +-------+------------+------------------------------+
       |  0x09 | length     | 9 octets (len&lt;240 1-octet)   |
       |  0x01 | type       | Type 1 - Destination Prefix  |
       |  0x20 | length     | 32 bit                       |
       |  0xc0 | prefix     | 192                          |
       |  0x00 | prefix     | 0                            |
       |  0x02 | prefix     | 2                            |
       |  0x01 | prefix     | 1                            |
       |  0x0c | type       | Type 12 - Fragment           |
       |  0x80 | bitmask_op | end-of-list, value size=1    |
       |  0x05 | bitmask    | DF=1, FF=1                   |
       +-------+------------+------------------------------+
</artwork>
</figure>
This constitutes an NLRI with an NLRI length of 9 octets.
</t>
</section>
</section>
</section>
<section anchor="traffic_filtering" title="Traffic Filtering">
    <t>
   Traffic filtering policies have been traditionally considered to be relatively
 static.  Limitations of these static mechanisms caused this new dynamic mechanism to be
 designed for the three new applications of traffic filtering:
    <list style="symbols">
        <t>Prevention of traffic-based, denial-of-service (DOS) attacks.</t>
        <t>Traffic filtering in the context of BGP/MPLS VPN service.</t>
        <t>Centralized traffic control for SDN/NFV networks.</t>
    </list>
 These application require coordination among service providers and/or coordination
 among the AS within a service provider.  <xref target="limitations_previous_ddos" /> and
        <xref target="limitations_previous_mpls_ddos" /> explain details on the
 limitation of previous mechanisms and why Flow Specification
 provides a solution to prevent DOS and aid BGP/MPLS VPN filtering rules.
	</t>
	<t>
	The Flow Specification NLRI defined above to convey information about traffic
filtering rules for traffic that should be discarded or handled in a manner
specified by a set of pre-defined actions (which are defined in BGP Extended
Communities). This mechanism is primarily designed to allow an upstream
autonomous system to perform inbound filtering in their ingress routers of
traffic that a given downstream AS wishes to drop.
   </t>
   <t>
   In order to achieve this goal, this draft specifies two application specific
   NLRI identifiers that provide traffic filters, and a set of actions encoding
   in BGP Extended Communities.  The two application specific NLRI identifiers
   are:
   <list style="symbols">
   <t>
     IPv4 Flow Specification identifier (AFI=1, SAFI=133) along with specific
     semantic rules for IPv4 routes, and
   </t>
   <t>
     VPNv4 Flow Specification identifier (AFI=1, SAFI=134)
     value, which can be used to propagate traffic filtering information
     in a BGP/MPLS VPN environment.
   </t>
   </list>
   </t>
   <t>
       Encoding of the NLRI is described in <xref target="dissemination_ipv4_flowspec" /> for IPv4 Flow Specification and   in
       <xref target="traffic_filtering_vpn" /> for VPNv4 Flow Specification. The filtering actions are described
       in <xref target="traffic_filtering_actions" />.
   </t>
<section title="Ordering of Flow Specifications">
<t>
   More than one Flow Specification may match a
   particular traffic flow.  Thus, it is necessary to define the order
   in which Flow Specifications get matched and actions being applied to a
   particular traffic flow.
   This ordering function is such that it does not depend on the arrival order
   of the Flow Specification via BGP and thus is consistent in the network.
</t>
<t>
   The relative order of two Flow Specifications is determined by
   comparing their respective components. The algorithm starts by
   comparing the left-most components (lowest component type value) of the
   Flow Specifications.  If the types
   differ, the Flow Specification with lowest numeric type value has higher precedence
   (and thus will match before) than the Flow Specification that doesn't contain that
   component type. If the component types are the same, then a type-
   specific comparison is performed (see below) if the types are equal the
   algorithm continues with the next component.
</t>
<t>
  For IP prefix values (IP destination or source prefix): If one of the
    two prefixes to compare is a more specific prefix of the other, the more
    specific prefix has higher precedence. Otherwise the one with the
    lowest IP value has higher precedence.
</t>
<t>
   For all other component types, unless otherwise specified, the comparison is
   performed by comparing the component data as a binary string using the
   memcmp() function as defined by <xref target="ISO_IEC_9899" />. For strings with equal
   lengths the lowest string (memcmp) has higher precedence. For strings of
   different lengths, the common prefix is compared. If the common prefix is not
   equal the string with the lowest prefix has higher precedence. If the common
   prefix is equal, the longest string is considered to have higher precedence
   than the shorter one.
</t>

<t>
  The code in <xref target="flow_rule_cmp_src" /> shows a Python3 implementation
  of the comparison algorithm. The full code was tested with Python 3.6.3 and can be
  obtained at <eref target="https://github.com/stoffi92/flowspec-cmp">https://github.com/stoffi92/flowspec-cmp</eref>.
</t>
</section>
	</section>
<section title="Validation Procedure" anchor="validation_procedure">
<t>Flow Specifications received from a BGP peer that are accepted in
   the respective Adj-RIB-In are used as input to the route selection
   process.  Although the forwarding attributes of two routes for the
   same Flow Specification prefix may be the same, BGP is still required
   to perform its path selection algorithm in order to select the
   correct set of attributes to advertise.
</t>
<t>
   The first step of the BGP Route Selection procedure (Section 9.1.2 of
   <xref target="RFC4271"></xref> is to exclude from the
   selection procedure routes that are
   considered non-feasible.  In the context of IP routing information,
   this step is used to validate that the NEXT_HOP attribute of a given
   route is resolvable.
</t>
<t>
   The concept can be extended, in the case of the Flow Specification NLRI,
   to allow other validation procedures.
</t>
<t>
   A Flow Specification NLRI must be validated such that it is
   considered feasible if and only if all of the below is true:
<list>
<t>
  a) A destination prefix component is embedded in the Flow Specification.
</t>
<t>
  b) The originator of the Flow Specification matches the originator of
  the best-match unicast route for the destination prefix embedded
  in the Flow Specification (this is the unicast route with the longest
    possible prefix length covering the destination prefix embedded in
    the Flow Specification).
</t>
<t>
  c) There are no more specific unicast routes, when compared with the
  flow destination prefix, that have been received from a different
  neighboring AS than the best-match unicast route, which has been
  determined in rule b).
</t>
</list>
</t>
<t>
  Rule a) MAY be relaxed by configuration, permitting Flow
  Specifications that include no destination prefix component. If such
  is the case, rules b) and c) are moot and MUST be disregarded.
</t>
<t>
   By originator of a BGP route, we mean either the address of the
    originator in the ORIGINATOR_ID Attribute <xref target="RFC4456" />,
    or the source IP address of the BGP peer, if this path attribute is
    not present.
</t>
<t>
   BGP implementations MUST also enforce that the AS_PATH attribute of a
   route received via the External Border Gateway Protocol (eBGP)
   contains the neighboring AS in the left-most position of the AS_PATH
   attribute.  While this rule is optional in the BGP specification, it
   becomes necessary to enforce it for security reasons.
</t>
<t>
The best-match unicast route may change over the time independently of the
Flow Specification NLRI.  Therefore, a revalidation of the Flow Specification
NLRI MUST be performed whenever unicast routes change.  Revalidation is
defined as retesting that clause a and clause b above are true.
</t>
<t>Explanation:
</t>
<t>
   The underlying concept is that the neighboring AS that advertises the
   best unicast route for a destination is allowed to advertise Flow
   Specification information that conveys a more or equally specific destination
   prefix.  Thus, as long as there are no more specific unicast routes,
   received from a different neighboring AS, which would be affected by
   that Flow Specification.
</t>
<t>
   The neighboring AS is the immediate destination of the traffic
   described by the Flow Specification.  If it requests these flows to
   be dropped, that request can be honored without concern that it
   represents a denial of service in itself.  Supposedly, the traffic is
   being dropped by the downstream autonomous system, and there is no
   added value in carrying the traffic to it.
</t>
</section>
<section anchor="traffic_filtering_actions" title="Traffic Filtering Actions">
<t>
   This document defines a minimum set of Traffic Filtering Actions that it
   standardizes as BGP extended community values <xref target="RFC4360"></xref>.
   This is not meant to be an inclusive list of all the possible actions, but only a
   subset that can be interpreted consistently across the network.
   Additional actions can be defined as either requiring standards or
   as vendor specific.
 </t>
 <t>
    Implementations SHOULD provide mechanisms that map an arbitrary BGP
   community value (normal or extended) to Traffic Filtering Actions that
   require different mappings in different systems in the network.  For
   instance, providing packets with a worse-than-best-effort, per-hop
   behavior is a functionality that is likely to be implemented
   differently in different systems and for which no standard behavior
   is currently known.  Rather than attempting to define it here, this
   can be accomplished by mapping a user-defined community value to
   platform-/network-specific behavior via user configuration.
 </t>
 <t>
    The default action for a matching Flow Specification is to
    accept the packet (treat the packet according to the normal forwarding
    behaviour of the system).
 </t>
 <t>This document defines the following extended communities values
 shown in <xref target="traffic_extended_communities" /> in the form
 0xttss where tt indicates the type and ss indicates the sub-type of the extended community.
 Encodings for these extended communities are described below.
 </t>
   <texttable anchor="traffic_extended_communities" title="Traffic Filtering Action
     Extended Communities">
       <ttcol align="left">community 0xttss</ttcol>
       <ttcol align="left">action</ttcol>
       <ttcol align="left">encoding</ttcol>
       <c>0x8006</c> <c>traffic-rate-bytes (<xref target="traffic_rate_in_bytes" />)</c>      <c>2-byte ASN, 4-byte float</c>
       <c>TBD</c>    <c>traffic-rate-packets (<xref target="traffic_rate_in_bytes" />)</c>    <c>2-byte ASN, 4-byte float</c>
       <c>0x8007</c> <c>traffic-action (<xref target="traffic_action_subtype" />)</c>          <c>bitmask</c>
       <c>0x8008</c> <c>rt-redirect AS-2byte (<xref target="rt_redirect_action_subtype" />)</c>  <c>2-octet AS, 4-octet value</c>
       <c>0x8108</c> <c>rt-redirect IPv4 (<xref target="rt_redirect_action_subtype" />)</c>      <c>4-octet IPv4 addres, 2-octet value</c>
       <c>0x8208</c> <c>rt-redirect AS-4byte (<xref target="rt_redirect_action_subtype" />)</c>  <c>4-octet AS, 2-octet value</c>
       <c>0x8009</c> <c>traffic-marking (<xref target="traffic_marking_subtype" />)</c>         <c>DSCP value</c>
   </texttable>
<t>
    Multiple Traffic Filtering Actions defined in this document may be present for a single Flow Specification.
    If not all of them can be processed the Traffic Filtering Actions SHALL NOT
    be applied at all to that packet. For example: If for a given Flow Specification there
    are the Traffic Filtering Actions traffic-rate-bytes (0x8006) and
    traffic-marking (0x8009) attached, and the platform does not support
    one of them, none of the actions shall be applied.
</t>
 <t>
 Some Traffic Filtering Actions may interfere with each other.
 <xref target="rules_action_interference" /> of this document
 provides general considerations on such Traffic Filtering Action interference.
 Any additional definition of a Traffic Filtering Actions MUST specify
 the action to take if those Traffic Filtering Actions interfere (also with existing
     Traffic Filtering Actions).
</t>
<t>
All Traffic Filtering Actions are specified as transitive BGP Extended
Communities.
</t>
 <section anchor="traffic_rate_in_bytes" title="Traffic Rate in Bytes (traffic-rate-bytes) sub-type 0x06">
 <t>The traffic-rate-bytes extended community uses the following
   extended community encoding:
 </t>
<t>
 The first two octets carry the 2-octet id, which can be
 assigned from a 2-byte AS number.  When a 4-byte AS number is
 locally present, the 2 least significant bytes of such an AS
 number can be used.  This value is purely informational and
 SHOULD NOT be interpreted by the implementation.
</t>
<t>
The remaining 4 octets carry the maximum rate information in IEEE floating point
<xref target="IEEE.754.1985"></xref> format, units being bytes per second.  A
traffic-rate of 0 should result on all traffic for the particular flow to be
discarded. On encoding the traffic-rate MUST NOT be negative. On
decoding negative values MUST be treated as zero (discard all traffic).
 </t>
 <t>Interferes with: No other BGP Flow Specification Traffic Filtering Action in
 this document.</t>
</section>
<section anchor="traffic_rate_in_packets" title="Traffic Rate in Packets (traffic-rate-packets) sub-type TBD">
<t>
  The traffic-rate-packets extended community uses the same encoding as the
  traffic-rate-bytes extended community. The floating point value carries the
  maximum packet rate in packets per second. A traffic-rate-packets of 0 should
  result in all traffic for the particular flow to be discarded. On encoding the
  traffic-rate-packets MUST NOT be negative.  On decoding negative values MUST
  be treated as zero (discard all traffic).
</t>
<t>Interferes with: No other BGP Flow Specification Traffic Filtering Action in
this document.</t>
</section>
 <section anchor="traffic_action_subtype" title="Traffic-action (traffic-action) sub-type 0x07">
 <t>The traffic-action extended community consists of 6
      bytes of which only the 2 least significant bits of the 6th byte
      (from left to right) are defined by this document as shown in
     <xref target="figure_traffic_action_encoding" />.
</t>
<t>
<figure title="Traffic-action Extended Community Encoding" anchor="figure_traffic_action_encoding">
<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Traffic Action Field                                          |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Tr. Action Field (cont.)  |S|T|
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>
</figure>
</t>
<t>where S and T are defined as:
<list style="symbols">
<t>T: Terminal Action (bit 47): When this bit is set, the traffic
   filtering engine will evaluate any subsequent Flow Specifications (as
   defined by the ordering procedure). If not set, the evaluation
   of the traffic filters stops when this Flow Specification is evaluated.
</t>
<t>S: Sample (bit 46): Enables traffic sampling and logging for this
     Flow Specification (only effective when set).
</t>
<t>Traffic Action Field: Other Traffic Action Field (see
    <xref target="IANA" />) bits unused in this
    specification.
</t>
</list>
</t>
<t>
  The use of the Terminal Action (bit 47) may result in more than one
  Flow Specification matching a particular traffic flow. All the
  Traffic Filtering Actions from these Flow Specifications
  shall be collected and applied. In case of interfering Traffic Filtering Actions
  it is an implementation decision which Traffic Filtering Actions are selected. See also <xref
  target="rules_action_interference" />.
</t>
<t>Interferes with: No other BGP Flow Specification Traffic Filtering Action in
this document.
</t>
</section>
 <section anchor="rt_redirect_action_subtype" title="RT Redirect (rt-redirect) sub-type 0x08">
 <t>The redirect extended community allows the traffic to be
  redirected to a VRF routing instance that lists the specified
  route-target in its import policy. If several local instances
  match this criteria, the choice between them is a local matter
  (for example, the instance with the lowest Route Distinguisher
  value can be elected).  This extended community allows 3 different
  encodings formats for the route-target (type 0x80, 0x81, 0x82).
  Is uses the same encoding as the Route Target extended community [RFC4360].
</t>
<t>Interferes with: No other BGP Flow Specification Traffic Filtering Action in
this document.
</t>
</section>
<section anchor="traffic_marking_subtype" title="Traffic Marking (traffic-marking) sub-type 0x09">
<t> The traffic marking extended community instructs a
 system to modify the DSCP bits of a transiting IP packet to the
 corresponding value encoded in the 6 least significant bits of the extended
    community value as shown in <xref target="figure_traffic_marking_encoding" />.
 </t>
    <t>The extended is encoded as follows:
<figure title="Traffic Marking Extended Community Encoding" anchor="figure_traffic_marking_encoding">
<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   reserved    |   reserved    |   reserved    |   reserved    |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   reserved    | r.|    DSCP   |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>
</figure>
</t>
<t>
<list style="symbols">
<t>DSCP: new DSCP value for the transiting IP packet.
</t>
<t>reserved, r.: SHOULD be set to 0 on encoding, and MUST be
         ignored during decoding.
</t>
</list>
</t>


 <t>Interferes with: No other BGP Flow Specification Traffic Filtering Action in
 this document.</t>
</section>
 <section anchor="rules_action_interference" title="Considerations on Traffic Filtering Action Interference">
<t>
   Since Traffic Filtering Actions are represented as BGP extended community values,
   Traffic Filtering Actions may interfere with each other (e.g. there may be more than
   one conflicting traffic-rate-bytes Traffic Filtering Action associated with a single
   Flow Specification). Traffic Filtering Action interference has no impact on BGP propagation
   of Flow Specifications (all communities are propagated according to policies).
</t>
<t>
   If a Flow Specification associated with interfering Traffic Filtering Actions is selected for
   packet forwarding, it is an implementation decision which of the interfering
   Traffic Filtering Actions are selected. Implementors of this specification SHOULD
   document the behaviour of their implementation in such cases.
</t>
<t>
   Operators are encouraged to make use of the BGP policy framework
   supported by their implementation in order to achieve a predictable behaviour
   (ie. match - replace - delete communities on administrative boundaries). See also
    <xref target="security_considerations" />.
</t>
</section>
</section>

<section anchor="traffic_filtering_vpn" title="Dissemination of Traffic Filtering in BGP/MPLS VPN Networks">
<t>
   Provider-based Layer 3 VPN networks, such as the ones using a BGP/ MPLS IP
   VPN <xref target="RFC4364"></xref> control plane, may have different traffic
   filtering requirements than Internet service providers. But also Internet
   service providers may use those VPNs for scenarios like having the Internet
   routing table in a VRF, resulting in the same traffic filtering requirements
   as defined for the global routing table environment within this document.
   This document defines an additional BGP NLRI type (AFI=1, SAFI=134) value,
   which can be used to propagate Flow Specification in a BGP/MPLS
   VPN environment.
 </t>
<t>
   The NLRI format for this address family consists of a fixed-length Route
   Distinguisher field (8 bytes) followed by the Flow Specification NLRI value <xref target="nlri_value_encoding" />.
   The NLRI length field shall include both the 8 bytes of the Route
   Distinguisher as well as the subsequent Flow Specification NLRI value.
   The resulting encoding is shown in <xref target="figure_fs_nlri_mpls" />.
</t>
<t>
<figure title="Flow Specification NLRI for MPLS" anchor="figure_fs_nlri_mpls">
  <artwork>
                  +------------------------------+
                  | length (0xnn or 0xfn nn)     |
                  +------------------------------+
                  | Route Distinguisher (8 bytes)|
                  +------------------------------+
                  |    NLRI value  (variable)    |
                  +------------------------------+
  </artwork>
</figure>
</t>
<t>
   Propagation of this NLRI is controlled by matching Route Target
   extended communities associated with the BGP path advertisement with
   the VRF import policy, using the same mechanism as described in BGP/
   MPLS IP VPNs <xref target="RFC4364"></xref>.
</t>
<t>
   Flow Specifications received via this NLRI apply only to traffic
   that belongs to the VRF(s) in which it is imported. By default,
   traffic received from a remote PE is switched via an MPLS forwarding
   decision and is not subject to filtering.
</t>
<t>
   Contrary to the behavior specified for the non-VPN NLRI, Flow Specifications
   are accepted by default, when received from remote PE routers.
</t>
<t>
    The validation procedure (<xref target="validation_procedure" />) and
    Traffic Filtering Actions (<xref target="traffic_filtering_actions" />) are the same as
    for IPv4.
</t>
</section>
<section title="Traffic Monitoring">
<t>
   Traffic filtering applications require monitoring and traffic
   statistics facilities.  While this is an implementation specific
   choice, implementations SHOULD provide:
   <list style="symbols">
   <t> A mechanism to log the packet header of filtered traffic.
   </t>
   <t>A mechanism to count the number of matches for a given Flow
      Specification.
   </t>
   </list>
  </t>
</section>
<section anchor="errorhandling" title="Error-Handling">
  <t>
      Error handling according to <xref target="RFC7606"></xref> SHOULD
      apply to this specification.
  </t>
    <t>
        This document introduces Traffic Filtering Action Extended Communities.
        Malformed Traffic Filtering Action Extended Communities in the sense of <xref target="RFC7606"></xref>
        Section 7.14. are Extended Community values that cannot be decoded according
        to <xref target="traffic_filtering_actions" /> of this document.
    </t>
</section>
<section anchor="future_extensions" title="Future NLRI Extensions">
    <t>
      Future Flow Specification extensions may introduce new Flow
      Specification components. In order to facilitate such extensions of
      the Flow Specification NLRI, in addition to the cases described in
      <xref target="RFC7606"></xref>, if BGP encounters an unknown Flow
      Specification component in an UPDATE message, it SHOULD also treat
      this message as Treat-as-withdraw as specified in
      <xref target="RFC7606"></xref> Section 2.
  </t>
  <t>
      The specification of a new Flow Specification Component Type SHOULD
      clearly identify what the criteria used to match packets forwarded by the
      router is. This criteria should be meaningful across router hops and
      not depend on values that change hop-by-hop such as TTL or Layer 2
      encapsulation.
  </t>
  <t>
    Such extensions SHOULD also specify a way to encode an "always-match" match condition within
    the newly introduced components (this is a match condition, encoded with the newly introduced components:
    If present on its own, matches all flows). This match condition can be used to propagate (and apply)
    certain Flow Specifications only if a specific extension is known to the implementation.
  </t>
</section>

<section anchor="IANA" title="IANA Considerations">
  <t>
    This section complies with <xref target="RFC7153"></xref>.
  </t>
  <section title="AFI/SAFI Definitions">
    <t>
      IANA maintains a registry entitled "SAFI Values". For the purpose of this
      work, IANA is requested to update the following SAFIs according to the table below
         (Note: This document obsoletes both RFC7674 and RFC5575 and all references
      to those should be deleted from the registry below):
    </t>
    <texttable anchor="iana_safi" title="Registry: SAFI Values">
          <ttcol align="left">Value</ttcol>
          <ttcol align="left">Name</ttcol>
          <ttcol align="left">Reference</ttcol>
          <c>133</c>   <c>Dissemination of Flow Specification rules</c>  <c>[this document]</c>
          <c>134</c>   <c>L3VPN Dissemination of Flow Specification rules</c>       <c>[this document]</c>
    </texttable>
  </section>
    <section title="Renaming of Experimental Use Registries">
        <t>IANA is asked to rename the registry entitled "Generic
            Transitive Experimental Use Extended Community Part 2 Sub-Types" to
            "Generic Transitive Extended Community Part 2 Sub-Types" and
            update the reference for this registry to [this document].
        </t>
        <t>IANA is asked to rename the registry entitled "Generic
            Transitive Experimental Use Extended Community Part 3 Sub-Types" to
            "Generic Transitive Extended Community Part 3 Sub-Types" and
            update the reference for this registry to [this document].
        </t>
    </section>
  <section title="Flow Component Definitions">
    <t>
      A Flow Specification consists of a sequence of flow components, which
      are identified by a an 8-bit component type. IANA has created and maintains
      a registry entitled "Flow Spec Component Types". IANA is asked to
      update the reference for this registry to [this document]. Furthermore the
      references to the values should be updated according to the table below
      (Note: This document obsoletes both RFC7674 and RFC5575 and all references
      to those should be deleted from the registry below).
    </t>

    <texttable anchor="iana_flow_component_types" title="Registry: Flow Spec Component Types">
          <ttcol align="left">Value</ttcol>
          <ttcol align="left">Name</ttcol>
          <ttcol align="left">Reference</ttcol>
          <c>1</c>   <c>Destination Prefix</c>  <c>[this document]</c>
          <c>2</c>   <c>Source Prefix</c>       <c>[this document]</c>
          <c>3</c>   <c>IP Protocol</c>         <c>[this document]</c>
          <c>4</c>   <c>Port</c>                <c>[this document]</c>
          <c>5</c>   <c>Destination port</c>    <c>[this document]</c>
          <c>6</c>   <c>Source port</c>         <c>[this document]</c>
          <c>7</c>   <c>ICMP type</c>           <c>[this document]</c>
          <c>8</c>   <c>ICMP code</c>           <c>[this document]</c>
          <c>9</c>   <c>TCP flags</c>           <c>[this document]</c>
          <c>10</c>  <c>Packet length</c>       <c>[this document]</c>
          <c>11</c>  <c>DSCP</c>                <c>[this document]</c>
          <c>12</c>  <c>Fragment</c>            <c>[this document]</c>
    </texttable>
    <t>
      In order to manage the limited number space and accommodate several
      usages, the following policies defined by <xref target="RFC8126" />
      are used:
    </t>
    <texttable anchor="iana_flow_component_types_policies" title="Flow Spec Component Types Policies">
          <ttcol align="left">Type Values</ttcol>
          <ttcol align="left">Policy</ttcol>
          <c>0</c>           <c>Specification required</c>
          <c>[1 .. 12]</c>   <c>Defined by this specification</c>
          <c>[13 .. 127]</c>   <c>Specification required</c>
          <c>[128 .. 255]</c>   <c>First Come First Served</c>
    </texttable>
  </section>
 <section title="Extended Community Flow Specification Actions">
 <t>The Extended Community Flow Specification Action types defined in this document
   consist of two parts:
   <list>
     <t>Type (BGP Transitive Extended Community Type)</t>
     <t>Sub-Type</t>
   </list>
 </t>


   <t>
     For the type-part, IANA maintains a registry entitled "BGP Transitive Extended Community
     Types". For the purpose of this work (<xref
     target="traffic_filtering_actions" />), IANA is asked to update the
     references to the following values according to the table below (Note: This document obsoletes both
     RFC7674 and RFC5575 and all references to those should be deleted in the registry below):
   </t>
   <texttable anchor="iana_ext_comm_types" title="Registry: Generic Transitive Experimental Use Extended Community Types">
         <ttcol align="left">Type Value</ttcol>
         <ttcol align="left">Name</ttcol>
         <ttcol align="left">Reference</ttcol>
         <c>0x81</c>
         <c>
           Generic Transitive Extended Community Part 2 (Sub-Types are
           defined in the "Generic Transitive Extended Community Part 2
           Sub-Types" Registry)
         </c>
         <c>[this document]</c>

         <c>0x82</c>
         <c>
           Generic Transitive Extended Community Part 3
           (Sub-Types are defined in the "Generic Transitive
           Extended Community Part 3 Sub-Types" Registry)
         </c>
         <c>[this document]</c>

   </texttable>
   <t>
     For the sub-type part of the extended community Traffic Filtering Actions IANA maintains
     the following registries. IANA is asked to update all names and references
     according to the tables below and assign a new value for the "Flow spec
     traffic-rate-packets" Sub-Type (Note: This document obsoletes both
     RFC7674 and RFC5575 and all references to those should be deleted from the registries below).
   </t>
   <texttable anchor="iana_ext_comm_subtypes" title="Registry: Generic Transitive Experimental Use Extended Community Sub-Types">
         <ttcol align="left">Sub-Type Value</ttcol>
         <ttcol align="left">Name</ttcol>
         <ttcol align="left">Reference</ttcol>
         <c>0x06</c>
         <c>
           Flow spec traffic-rate-bytes
         </c>
         <c>[this document]</c>

         <c>TBD</c>
         <c>
           Flow spec traffic-rate-packets
         </c>
         <c>[this document]</c>

         <c>0x07</c>
         <c>
           Flow spec traffic-action (Use of the "Value" field is defined in the "Traffic Action Fields" registry)
         </c>
         <c>[this document]</c>

         <c>0x08</c>
         <c>
           Flow spec rt-redirect AS-2byte format
         </c>
         <c>[this document]</c>

         <c>0x09</c>
         <c>
           Flow spec traffic-remarking
         </c>
         <c>[this document]</c>

   </texttable>

   <texttable anchor="iana_ext_comm_subtypes2" title="Registry: Generic Transitive Extended Community Part 2 Sub-Types (has been renamed above)">
         <ttcol align="left">Sub-Type Value</ttcol>
         <ttcol align="left">Name</ttcol>
         <ttcol align="left">Reference</ttcol>
         <c>0x08</c>
         <c>
           Flow spec rt-redirect IPv4 format
         </c>
         <c>[this document]</c>
   </texttable>
   <texttable anchor="iana_ext_comm_subtypes3" title="Registry: Generic Transitive Extended Community Part 3 Sub-Types (has been renamed above)">
         <ttcol align="left">Sub-Type Value</ttcol>
         <ttcol align="left">Name</ttcol>
         <ttcol align="left">Reference</ttcol>
         <c>0x08</c>
         <c>
           Flow spec rt-redirect AS-4byte format
         </c>
         <c>[this document]</c>
   </texttable>
   <t>
     The "traffic-action" extended community (<xref
     target="traffic_action_subtype" />) defined in this document has 46 unused bits,
     which can be used to convey additional meaning. IANA
     created and maintains a new registry entitled: "Traffic Action
     Fields".  IANA is asked to update the reference for this registry to
     [this document]. Furthermore IANA is asked to update the references according to the table below.
     These values should be assigned via IETF Review rules only (Note: This document obsoletes both
     RFC7674 and RFC5575 and all references to those should be deleted from the registry below).
   </t>
   <texttable anchor="iana_traffic_action_subtype" title="Registry: Traffic Action Fields">
         <ttcol align="left">Bit</ttcol>
         <ttcol align="left">Name</ttcol>
         <ttcol align="left">Reference</ttcol>
         <c>47</c><c>Terminal Action</c><c>[this document]</c>
         <c>46</c><c>Sample</c><c>[this document]</c>
   </texttable>
</section>
</section>
  <section title="Security Considerations" anchor="security_considerations">
   <t> As long as Flow Specifications are restricted to match the
   corresponding unicast routing paths for the relevant prefixes (<xref target="validation_procedure" />),
   the security characteristics of this proposal are equivalent to the existing security
   properties of BGP unicast routing. Any relaxation of the validation
   procedure described in <xref target="validation_procedure" /> may
   allow unwanted Flow Specifications to be propagated and thus unwanted Traffic
   Filtering Actions may be applied to flows.
    </t>
   <t>  Where the above mechanisms are not in place, this would open the door
   to further denial-of-service attacks such as unwanted traffic filtering,
   remarking or redirection.
   </t>
   <t>
       Inter-provider routing is based on a web of trust. Neighboring
   autonomous systems are trusted to advertise valid reachability
   information. If this trust model is violated, a neighboring
   autonomous system may cause a denial-of-service attack by advertising
   reachability information for a given prefix for which it does not
   provide service (unfiltered address space hijack). Since validation
   of the Flow Specification is tied to the announcement of
   the best unicast route, this may also cause this validation to fail
   and consequently prevent Flow Specifications from being accepted
   by a peer. Possible mitigations are <xref target="RFC6811" /> and
   <xref target="RFC8205" />.
   </t>
   <t> Enabling firewall-like capabilities in routers without centralized
   management could make certain failures harder to diagnose.  For
   example, it is possible to allow TCP packets to pass between a pair
   of addresses but not ICMP packets.  It is also possible to permit
   packets smaller than 900 or greater than 1000 bytes to pass between a
    pair of addresses, but not packets whose length is in the range 900-
   1000.  Such behavior may be confusing and these capabilities should
   be used with care whether manually configured or coordinated through
   the protocol extensions described in this document.
  </t>
  <t>
      Flow Specification BGP speakers (e.g. automated DDoS controllers) not properly programmed,
      algorithms that are not performing as expected, or simply rogue systems
      may announce unintended Flow Specifications, send updates at a high rate
      or generate a high number of Flow Specifications.
      This may stress the receiving systems, exceed their maximum capacity or
      may lead to unwanted Traffic Filtering Actions being applied to flows.
  </t>
    <t> While the general verification of the Flow Specification NLRI
    is specified in this document (<xref target="validation_procedure" />) the Traffic Filtering
    Actions received by a third party may need custom verification or filtering. In particular
    all non traffic-rate actions may allow a third party to modify packet forwarding properties and potentially
    gain access to other routing-tables/VPNs or undesired queues. This can be avoided by proper filtering/screening of the
    Traffic Filtering Action communities
    at network borders and only exposing a predefined subset of Traffic Filtering Actions (see <xref target="traffic_filtering_actions" />)
    to third parties. One way to achieve this is by mapping user-defined communities, that can be set by the third party, to
    Traffic Filtering Actions and not accepting Traffic Filtering Action extended communities from third parties.
    </t>
      <t>This extension adds additional information to Internet routers.
          These are limited in terms of the maximum number of data elements
          they can hold as well as the number of events they are able to
          process in a given unit of time. Service providers need to consider
          the maximum capacity of their devices and may need to limit the
          number of Flow Specifications accepted and processed.
   </t>
  </section>
	<section title="Contributors">
	<t>Barry Greene,  Pedro Marques, Jared Mauch, Danny McPherson,
	and Nischal Sheth were authors on <xref target="RFC5575" />, and therefore
	are contributing authors on this document.
	</t>
	</section>
	<section title="Acknowledgements">
   <t>The authors would like to thank Yakov Rekhter, Dennis Ferguson, Chris
   Morrow, Charlie Kaufman, and David Smith for their comments for the comments on
   the original <xref target="RFC5575" />.  Chaitanya Kodeboyina
   helped design the flow validation procedure; and Steven Lin and Jim Washburn
   ironed out all the details necessary to
   produce a working implementation in the original <xref target="RFC5575" />.
   </t>
   <t>
   A packet rate Traffic Filtering Action was also described in a Flow Specification extension draft
   and the authors like to thank Wesley Eddy, Justin Dailey and Gilbert Clark for
   their work.
   </t>
   <t>Additionally, the authors would like to thank Alexander Mayrhofer, Nicolas Fevrier,
   Job Snijders, Jeffrey Haas and Adam Chappell for their comments and review.
   </t>
	</section>
  </middle>
  <back>

    <references title="Normative References">
      &RFC0768;
      &RFC0791;
      &RFC0792;
	  &RFC0793;
      &RFC2119;
	  &RFC2474;
      &RFC4271;
	  &RFC4360;
	  &RFC4364;
      &RFC4456;
	  &RFC4760;
	  &RFC7153;
	  &RFC7606;
    &RFC8126;
    &RFC8174;

    <reference anchor="ISO_IEC_9899">
        <front>
            <title>Information technology -- Programming languages -- C</title>
            <author>
                <organization>ISO</organization>
            </author>
            <date month="June" year="2018" />
        </front>
        <seriesInfo name="ISO/IEC" value="9899:2018"/>
    </reference>
    <reference anchor="IEEE.754.1985">
        <front>
            <title>Standard for Binary Floating-Point Arithmetic</title>
            <author>
                <organization>IEEE</organization>
            </author>
            <date month="August" year="1985" />
        </front>
        <seriesInfo name="IEEE" value="754-1985"/>
    </reference>
	</references>
	<references title="Informative References">
	  &RFC4303;
      &RFC3882;
      &RFC5575;
      &RFC5635;
      &RFC6811;
      &RFC8205;
      &RFC7674;
      &RFC7999;
	  &I-D.ietf-idr-flow-spec-v6;
    </references>
    <section title="Python code: flow_rule_cmp" anchor="flow_rule_cmp_src">
<t>
  <figure>
    <artwork><![CDATA[
<CODE BEGINS>
"""
Copyright (c) 2019 IETF Trust and the persons identified as authors of
the code. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in Section
4.c of the IETF Trust’s Legal Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info).
"""

import itertools
import ipaddress

def flow_rule_cmp(a, b):
    for comp_a, comp_b in itertools.zip_longest(a.components,
                                           b.components):
        # If a component type does not exist in one rule
        # this rule has lower precedence
        if not comp_a:
            return B_HAS_PRECEDENCE
        if not comp_b:
            return A_HAS_PRECEDENCE
        # higher precedence for lower component type
        if comp_a.component_type < comp_b.component_type:
            return A_HAS_PRECEDENCE
        if comp_a.component_type > comp_b.component_type:
            return B_HAS_PRECEDENCE
        # component types are equal -> type specific comparison
        if comp_a.component_type in (IP_DESTINATION, IP_SOURCE):
            # assuming comp_a.value, comp_b.value of type ipaddress
            if comp_a.value.overlaps(comp_b.value):
                # longest prefixlen has precedence
                if comp_a.value.prefixlen > comp_b.value.prefixlen:
                    return A_HAS_PRECEDENCE
                if comp_a.value.prefixlen < comp_b.value.prefixlen:
                    return B_HAS_PRECEDENCE
                # components equal -> continue with next component
            elif comp_a.value > comp_b.value:
                return B_HAS_PRECEDENCE
            elif comp_a.value < comp_b.value:
                return A_HAS_PRECEDENCE
        else:
            # assuming comp_a.value, comp_b.value of type bytearray
            if len(comp_a.value) == len(comp_b.value):
                if comp_a.value > comp_b.value:
                    return B_HAS_PRECEDENCE
                if comp_a.value < comp_b.value:
                    return A_HAS_PRECEDENCE
                # components equal -> continue with next component
            else:
                common = min(len(comp_a.value), len(comp_b.value))
                if comp_a.value[:common] > comp_b.value[:common]:
                    return B_HAS_PRECEDENCE
                elif comp_a.value[:common] < comp_b.value[:common]:
                    return A_HAS_PRECEDENCE
                # the first common bytes match
                elif len(comp_a.value) > len(comp_b.value):
                    return A_HAS_PRECEDENCE
                else:
                    return B_HAS_PRECEDENCE
    return EQUAL
<CODE ENDS>
    ]]></artwork>
  </figure>
</t>
    </section>
    <section title="Comparison with RFC 5575">
      <t>
        This document includes numerous editorial changes to <xref target="RFC5575" />.
        It also completely incorporates the redirect action clarification document <xref target="RFC7674" />.
        It is recommended to read the entire document. The
        authors, however want to point out the following technical changes to
        <xref target="RFC5575" />:
        <list>
          <t>
            <xref target="intro" /> introduces the Flow Specification NLRI. In
            <xref target="RFC5575" /> this NLRI was defined as an opaque-key in BGPs database. This
            specification has removed all references to a opaque-key property.
           BGP is able to understand the NLRI encoding. This
            change also resulted in a new section regarding error-handling and
            extensibility (<xref target="errorhandling" /> and <xref target="future_extensions" />).
          </t>
          <t>
            <xref target="type_3" /> defines a numeric operator and comparison
            bit combinations. In <xref target="RFC5575" /> the meaning of those
            bit combination was not explicitly defined and left open to the
            reader.
          </t>
          <t>
            <xref target="type_3" /> - <xref target="type_8" />, <xref
            target="type_10" />, <xref target="type_11" /> make use of the above
            numeric operator. The allowed length of the comparison value was not
            consistently defined in <xref target="RFC5575" />.
          </t>
          <t>
            <xref target="traffic_filtering_actions" /> defines all Traffic
            Filtering Action Extended communities as transitive extended communities.
            <xref target="RFC5575" /> defined the traffic-rate action to be
            non-transitive and did not define the transitivity of the other
            Traffic Filtering Action communities at all.
          </t>
          <t>
            <xref target="traffic_rate_in_packets" /> introduces a new Traffic
            Filtering Action (traffic-rate-packets). This action did not exist
            in <xref target="RFC5575" />.
          </t>
          <t>
            <xref target="rt_redirect_action_subtype" /> contains the same
            redirect actions already defined in <xref target="RFC5575" />
            however, these actions have been renamed  to "rt-redirect" to make
            it clearer that the redirection is based on route-target.
            This section also completely incorporates the <xref target="RFC7674" />
            clarifications of the Flowspec Redirect Extended Community.
          </t>
          <t>
            <xref target="rules_action_interference" /> contains general
            considerations on interfering traffic actions.
            <xref target="traffic_action_subtype" /> also
            cross-references this section. <xref target="RFC5575" /> did not mention this.
          </t>
          <t>
            <xref target="errorhandling" /> contains new error handling.
          </t>
          <t>
            <xref target="future_extensions" /> describes graceful handling
              of unknown Flow Specification components to allow future extensions.
          </t>
        </list>


      </t>
    </section>

  </back>
  </rfc>
